上边的两种思路，时间复杂度都达不到题目的要求 $O(log(m+n)$。看到 log，很明显，我们只有用到二分的方法才能达到。我们不妨用另一种思路，题目是求中位数，其实就是求第 k 小数的一种特殊情况，而求第 k 小数有一种算法。

解法二中，我们一次遍历就相当于去掉不可能是中位数的一个值，也就是一个一个排除。由于数列是有序的，其实我们完全可以一半儿一半儿的排除。假设我们要找第 k 小数，我们可以每次循环排除掉 k/2 个数。看下边一个例子。

假设我们要找第 7 小的数字。
![image.png](https://pic.leetcode-cn.com/735ea8129ab5b56b7058c6286217fa4bb5f8a198e4c8b2172fe0f75b29a966cd-image.png)

我们比较两个数组的第 `k/2` 个数字，如果 `k` 是奇数，向下取整。也就是比较第 3 个数字，上边数组中的 4 和下边数组中的 3，如果哪个小，就表明该数组的前 `k/2` 个数字都不是第 k 小数字，所以可以排除。也就是 1，2，3 这三个数字不可能是第 7 小的数字，我们可以把它排除掉。将 `1,3,4,9` 和 `4,5,6,7,8,9,10` 两个数组作为新的数组进行比较。

更一般的情况 `A[1] ，A[2] ，A[3]，A[k/2]` ... ，`B[1]，B[2]，B[3]，B[k/2]` ... ，如果 $A[k/2]<B[k/2]$ ，那么$A[1], A[2], A[3], A[k/2]$都不可能是第 k 小的数字。

A 数组中比 $A[k/2]$ 小的数有$ k/2-1$ 个，B 数组中，$$B[k/2]$$ 比 $A[k/2]$ 小，$B[k/2]$ 前边的数字都比 $A[k/2]$ 小，有 $k/2-1$ 个，所以比 $A[k/2]$ 小的数字有 $k/2-1+k/2=k-1$个，所以 $A[k/2]$ 最多是第 $k $小的数。而比 $A[k/2]$ 小的数更不可能是第 $k$ 小的数了，所以可以把它们排除。

橙色的部分表示已经去掉的数字。

![image.png](https://pic.leetcode-cn.com/09b8649cd2b8bbea74f7f632b098fed5f8404530ff44b5a0b54a360b3cf7dd8f-image.png)

由于我们已经排除掉了 3 个数字，就是这 3 个数字一定在最前边，所以在两个新数组中，我们只需要找第 7 - 3 = 4 小的数字就可以了，也就是 $k = 4$。此时两个数组，比较第 2 个数字，$3 < 5$，所以我们可以把小的那个数组中的 1 ，3 排除掉了。

![image.png](https://pic.leetcode-cn.com/f2d72fd3dff109ad810895b9a0c8d8782f47df6b2f24f9de72704961bc547fcb-image.png)

我们又排除掉 2 个数字，所以现在找第 $4 - 2 = 2$ 小的数字就可以了。此时比较两个数组中的第 $k / 2 = 1$ 个数，$4 == 4$，怎么办呢？由于两个数相等，所以我们无论去掉哪个数组中的都行，因为去掉 1 个总会保留 1 个的，所以没有影响。为了统一，我们就假设 $4 > 4$ 吧，所以此时将下边的 4 去掉。

![image.png](https://pic.leetcode-cn.com/3c89a8ea29f2e19057b57242c8bc37c5f09b6796b96c30f3d42caea21c12f294-image.png)

由于又去掉 1 个数字，此时我们要找第 1 小的数字，所以只需判断两个数组中第一个数字哪个小就可以了，也就是 4。

所以第 7 小的数字是 4。

我们每次都是取 $k/2$ 的数进行比较，有时候可能会遇到数组长度小于 $k/2$的时候。

![image.png](https://pic.leetcode-cn.com/ad87d1f63a9bbd99e12605686290800ce61b03f9fb98d87f1d8c020d404421ac-image.png)

此时 k / 2 等于 3，而上边的数组长度是 2，我们此时将箭头指向它的末尾就可以了。这样的话，由于 2 < 3，所以就会导致上边的数组 1，2 都被排除。造成下边的情况。

![image.png](https://pic.leetcode-cn.com/7ea1963f184b1dcaddf951326ccbe7aa09cfbb9ebee7fffb2ede131853b3d1de-image.png)

由于 2 个元素被排除，所以此时 k = 5，又由于上边的数组已经空了，我们只需要返回下边的数组的第 5 个数字就可以了。

从上边可以看到，无论是找第奇数个还是第偶数个数字，对我们的算法并没有影响，而且在算法进行中，k 的值都有可能从奇数变为偶数，最终都会变为 1 或者由于一个数组空了，直接返回结果。

所以我们采用递归的思路，为了防止数组长度小于 k/2，所以每次比较 $min(k/2，len(数组) $对应的数字，把小的那个对应的数组的数字排除，将两个新数组进入递归，并且 k 要减去排除的数字的个数。递归出口就是当 k=1 或者其中一个数字长度是 0 了。
